<html>

<head>
    <title>Clipboard Explorer</title>
</head>

<body>
    <div>
        <p>Tip: Use copy/paste shortcuts or buttons below.</p>
        <fieldset style="display: inline;">
            <legend>Clipboard API</legend>
            <input type="checkbox" id="copy-check" title="Enable copy mode" />
            <input id="copy-btn" type="button" value="Copy" title="Copy using Clipboard API" disabled />
            <input id="paste-btn" type="button" value="Paste" title="Paste using Clipboard API" />
            <label for="clipboard-delay">Delay(ms):</label>
            <input id="clipboard-delay" type="number" step="100" style="width:6em" />
        </fieldset>

        <fieldset style="display: inline;">
            <legend>Content</legend>
            <label for="type-sel">Type:</label>
            <select id="type-sel" disabled></select>
            <label for="file-sel">File:</label>
            <select id="file-sel" disabled></select>
        </fieldset>
        <fieldset style="display: inline;">
            <legend>View as</legend>
            <input type="radio" id="mode1" name="mode" value="radio-text" checked />
            <label for="mode1">text</label>

            <input type="radio" id="mode2" name="mode" value="radio-html" />
            <label for="mode2">HTML</label>

            <input type="radio" id="mode3" name="mode" value="radio-img" />
            <label for="mode3">image</label>
        </fieldset>

        <hr />
    </div>
    <div id="view-area">
        <p id="details" hidden="true"></p>

        <img id="image-area" hidden="true" />
        <textarea id="text-area" style="width:100%; height:80%;" autofocus></textarea>
        <div id="html-area" hidden="true"></div>
    </div>
</body>
<script>
    // TODO: radio button for copy/paste mode
    // TODO: radio button for areas: Text, Image, HTML
    // TODO: expandable section for weird stuff (delay, etc)
    let img = document.getElementById('image-area');
    let txt = document.getElementById('text-area');
    let details = document.getElementById('details');
    let typeSel = document.querySelector('#type-sel');
    let fileSel = document.querySelector('#file-sel');
    let copyButton = document.querySelector("#copy-btn");
    let forHtml = document.querySelector('#html-area');
    let fileMap = {};
    let typeMap = {};

    function onRadioChange(e) {
        resetViewArea();
        if (e.target.value === 'radio-text') {
            txt.hidden = false;
            setText(typeMap[typeSel.value], 'text/plain');
        }
        else if (e.target.value === 'radio-html') {
            forHtml.hidden = false;
            setText(typeMap[typeSel.value], 'text/html');
        }
        else if (e.target.value === 'radio-img') {
            img.hidden = false;
        }

    }
    let modeRadio = document.querySelectorAll('input[type="radio"][name="mode"]');
    for (let i = 0; i != modeRadio.length; ++i) {
        modeRadio[i].addEventListener('change', onRadioChange);
    }

    async function setText(text, mimeType) {
        if (text instanceof Blob) {
            try {
                text = await text.text();
            } catch (e) {
                setDetails(e);
                return;
            }
        }

        let isString = text => typeof text === 'string' || text instanceof String;
        if (!isString(text)) {
            console.error(`Unexpected text type ${text.constructor.name}`);
            return;
        }

        if (mimeType === 'text/html') {
            forHtml.hidden = false;
            forHtml.innerHTML = text;
            return;
        }

        let rows = 1;
        let lineLen = 0;
        let maxLineLen = 0;
        // TODO: word wrap
        for (let i = 0; i != text.length; ++i) {
            let ch = text[i];
            ++lineLen;
            if (ch === '\n' || ch === '\r') {
                if (lineLen > maxLineLen)
                    maxLineLen = lineLen;
                lineLen = 0;
                ++rows;
            }
        }
        if (maxLineLen < lineLen)
            maxLineLen = lineLen;

        txt.value = text;
        txt.rows = rows;
        txt.cols = maxLineLen;

        txt.hidden = false;
    }

    function setImage(data) {
        img.src = URL.createObjectURL(data);
        img.hidden = false;
    }

    // TODO: error color
    function setDetails(text) {
        details.hidden = false;
        details.textContent = text;
    }

    function resetViewArea() {
        img.hidden = true;
        txt.hidden = true;
        forHtml.hidden = true;
    }

    function resetView() {
        details.hidden = true;
        resetViewArea();
    }
    function resetAll() {
        resetView();
        typeSel.disabled = true;
        while (typeSel.firstChild) {
            typeSel.removeChild(typeSel.firstChild);
        }
        fileSel.disabled = true;
        while (fileSel.firstChild) {
            fileSel.removeChild(fileSel.firstChild);
        }
        fileMap = {};
        typeMap = {};
    }

    async function pasteUsingApi() {
        resetAll();

        console.assert(navigator.clipboard);
        if (!navigator.clipboard) {
            setDetails('Error: Cannot use Clipboard API.');
            return;
        }

        let clipData = null;
        try {
            clipData = await navigator.clipboard.read();
        } catch (e) {
            setDetails(e);
            return;
        }

        for (let i = 0; i != clipData.length; ++i) {
            let item = clipData[i];
            console.log(`types: ${item.types}`);
            for (let j = 0; j != item.types.length; ++j) {
                let type = item.types[j];
                typeMap[type] = await item.getType(type);

                typeSel.disabled = false;
                let opt = document.createElement('option');
                opt.id = `type-sel-${i}`;
                opt.textContent = type;
                typeSel.append(opt);
            }
        }

        if (Object.keys(typeMap).length > 0) {
            typeSel.selectedIndex = 0;
            changeType(Object.keys(typeMap)[0]);
        }
    }

    document.querySelector("#paste-btn").addEventListener('click', async function (e) {
        console.log(`${e.timeStamp} ${e.type}`);

        document.querySelector('#copy-check').checked = false;
        copyButton.disabled = true;

        let delayValue = document.querySelector('#clipboard-delay').value;
        if (delayValue !== undefined && delayValue > 0) {
            setTimeout(pasteUsingApi, delayValue);
        } else {
            pasteUsingApi();
        }
    });

    function changeType(t) {
        resetView();
        let typeData = typeMap[t];
        if (typeData === undefined || typeData === null) {
            setDetails(`Error: Data for ${t} is null`);
            return;
        }
        fileSel.disabled = true;

        if (typeData.length !== undefined)
            setDetails(`size: ${typeData.length}, type: ${typeData.constructor.name}`);
        else if (typeData.size !== undefined)
            setDetails(`size: ${typeData.size}, type: ${typeData.constructor.name}`);

        if (t.startsWith('image/')) {
            setImage(typeData);
        } else if (t.startsWith('text/')) {
            setText(typeData, t);
        } else if (t === 'Files') {
            fileSel.disabled = false;
            fileSel.selectedIndex = 1;
            changeFile(Object.keys(fileMap)[0]);
        }
    }

    function changeFile(fileName) {
        resetView();
        let fileData = fileMap[fileName];
        if (fileData === undefined)
            return;
        setDetails(`type: ${fileData.type}, size: ${fileData.size}, modified: ${new Date(fileData.lastModified)}`);
        if (fileData.type.startsWith('image/')) {
            setImage(fileData);
        } else if (fileData.type.startsWith('text/')) {
            fileData.text().then((t) => setText(t));
        }
    }

    typeSel.addEventListener('change', function (e) {
        console.log(e);
        console.log(e.target.value);
        changeType(e.target.value);
    });
    fileSel.addEventListener('change', function (e) {
        console.log(e);
        console.log(e.target.value);
        changeFile(e.target.value);
    });

    document.querySelector('#copy-check').addEventListener('click', function (e) {
        if (e.target.checked) {
            copyButton.disabled = false;
            txt.hidden = false;
            txt.readOnly = undefined;
        } else {
            copyButton.disabled = true;
            txt.hidden = true;
        }
    });

    function isSafari() {
        if (window.safari !== undefined)
            return true;
        var ua = navigator.userAgent.toLowerCase();
        return ua.indexOf("safari/") !== -1 && ua.indexOf("chrom") === -1;
    }

    copyButton.addEventListener('click', function (e) {
        console.log(`${e.timeStamp} ${e.type}`);
        const canWriteClipboard = navigator.clipboard && typeof navigator.clipboard.write === 'function';
        console.assert(canWriteClipboard);
        if (!canWriteClipboard) {
            setDetails('Error: Cannot write using Clipboard API.');
            return;
        }
        let delayValue = document.querySelector('#clipboard-delay').value;
        if (delayValue === undefined || delayValue < 0)
            delayValue = 0;
        // TODO: more types
        let mimeType = "text/plain";
        let item = null;
        const usePromise = isSafari();  // this can be controlled from UI
        if (usePromise) {
            function later(delay, value) {
                return new Promise((resolve) => setTimeout(resolve, delay, value));
            }
            try {
                item = new ClipboardItem({ [mimeType]: later(delayValue, new Blob([txt.value], { type: mimeType })) });
                navigator.clipboard.write([item]);
                console.log('copied');
            } catch (e) {
                setDetails(e);
                return;
            }
        } else {
            setTimeout(async function () {
                try {
                    // TODO: reduce duplication
                    item = new ClipboardItem({ [mimeType]: new Blob([txt.value], { type: mimeType }) });
                    navigator.clipboard.write([item]);
                    console.log('copied');
                } catch (e) {
                    setDetails(e);
                    return;
                }
            }, delayValue);
        }
    });

    document.addEventListener("copy", function (e) {
        console.log(`${e.timeStamp} ${e.type}`);
        // TODO: more types
        e.clipboardData.setData('text/html', txt.value);
        e.preventDefault();
    });

    document.addEventListener("paste", function (e) {
        console.log(`${e.timeStamp} ${e.type}`);
        resetAll();

        console.log(`types: ${e.clipboardData.types}`);

        for (let i = 0; i != e.clipboardData.types.length; ++i) {
            let type = e.clipboardData.types[i];
            typeMap[type] = e.clipboardData.getData(type);

            typeSel.disabled = false;
            let opt = document.createElement('option');
            opt.id = `type-sel-${i}`;
            opt.textContent = type;
            typeSel.append(opt);
        }

        console.log(`files: ${e.clipboardData.files.length}`);

        for (let i = 0; i != e.clipboardData.files.length; ++i) {

            let f = e.clipboardData.files[i];

            if (fileSel.disabled) {
                fileSel.disabled = false;
                let opt = document.createElement('option');
                fileSel.append(opt);
            }
            let opt = document.createElement('option');
            opt.textContent = f.name;
            fileSel.append(opt);

            console.log(`  name: ${f.name}; type: ${f.type}; size: ${f.size}; modified: ${new Date(f.lastModified)}`);
            fileMap[f.name] = new File([f], f.name, { type: f.type, lastModified: f.lastModified });
        }

        if (Object.keys(typeMap).length > 0) {
            typeSel.selectedIndex = 0;
            changeType(Object.keys(typeMap)[0]);
        }
    });
</script>

</html>