<html>

<head>
</head>

<body>
    <div>
        <p>Tip: Use copy/paste shortcuts or buttons.</p>
        <input type="checkbox" id="copy-check" title="Enable copy mode" />
        <input id="copy-btn" type="button" value="Copy" title="Copy using Clipboard API" disabled />
        <input id="paste-btn" type="button" value="Paste" title="Paste using Clipboard API" />
        <label for="clipboard-delay">Delay(ms):</label>
        <input id="clipboard-delay" type="number" step="100" style="width:6em" />
        <span>|</span>
        <label for="type-sel">Type:</label>
        <select id="type-sel" disabled></select>
        <label for="file-sel">File:</label>
        <select id="file-sel" disabled></select>
        <hr />
    </div>
    <div>
        <p id="details" hidden="true"></p>
        <img id="img1" hidden="true" />
        <textarea id="text1" readonly="readonly" hidden="true" style="width:100%; height:80%;"></textarea>
        <div id="for-html" hidden="true"></div>
    </div>
</body>
<script>
    // TODO: radio button for copy/paste mode
    // TODO: radio button for areas: Text, Image, HTML
    // TODO: expandable section for weird stuff (delay, etc)
    let img = document.getElementById('img1');
    let txt = document.getElementById('text1');
    let details = document.getElementById('details');
    let typeSel = document.querySelector('#type-sel');
    let fileSel = document.querySelector('#file-sel');
    let copyButton = document.querySelector("#copy-btn");
    let forHtml = document.querySelector('#for-html');
    let fileMap = {};
    let typeMap = {};

    async function setText(text, mimeType) {
        if (text instanceof Blob) {
            try {
                text = await text.text();
            } catch (e) {
                setDetails(e);
                return;
            }
        }

        let isString = text => typeof text === 'string' || text instanceof String;
        if (!isString(text)) {
            console.error(`Unexpected text type ${text.constructor.name}`);
            return;
        }

        if (mimeType === 'text/html') {
            forHtml.hidden = false;
            forHtml.innerHTML = text;
            return;
        }

        let rows = 1;
        let lineLen = 0;
        let maxLineLen = 0;
        // TODO: word wrap
        for (let i = 0; i != text.length; ++i) {
            let ch = text[i];
            ++lineLen;
            if (ch === '\n' || ch === '\r') {
                if (lineLen > maxLineLen)
                    maxLineLen = lineLen;
                lineLen = 0;
                ++rows;
            }
        }
        if (maxLineLen < lineLen)
            maxLineLen = lineLen;

        txt.value = text;
        txt.rows = rows;
        txt.cols = maxLineLen;

        txt.hidden = false;
    }

    function setImage(data) {
        img.src = URL.createObjectURL(data);
        img.hidden = false;
    }

    // TODO: error color
    function setDetails(text) {
        details.hidden = false;
        details.textContent = text;
    }

    function resetView() {
        img.hidden = true;
        txt.hidden = true;
        details.hidden = true;
        forHtml.hidden = true;
    }
    function resetAll() {
        resetView();
        typeSel.disabled = true;
        while (typeSel.firstChild) {
            typeSel.removeChild(typeSel.firstChild);
        }
        fileSel.disabled = true;
        while (fileSel.firstChild) {
            fileSel.removeChild(fileSel.firstChild);
        }
        fileMap = {};
        typeMap = {};
    }

    async function pasteUsingApi() {
        resetAll();

        console.assert(navigator.clipboard);
        if (!navigator.clipboard) {
            setDetails('Error: Cannot use Clipboard API.');
            return;
        }

        let clipData = null;
        try {
            clipData = await navigator.clipboard.read();
        } catch (e) {
            setDetails(e);
            return;
        }

        for (let i = 0; i != clipData.length; ++i) {
            let item = clipData[i];
            console.log(`types: ${item.types}`);
            for (let j = 0; j != item.types.length; ++j) {
                let type = item.types[j];
                typeMap[type] = await item.getType(type);

                typeSel.disabled = false;
                let opt = document.createElement('option');
                opt.id = `type-sel-${i}`;
                opt.textContent = type;
                typeSel.append(opt);
            }
        }

        if (Object.keys(typeMap).length > 0) {
            typeSel.selectedIndex = 0;
            changeType(Object.keys(typeMap)[0]);
        }
    }

    document.querySelector("#paste-btn").addEventListener('click', async function (e) {
        console.log(`${e.timeStamp} ${e.type}`);

        document.querySelector('#copy-check').checked = false;
        copyButton.disabled = true;

        let delayValue = document.querySelector('#clipboard-delay').value;
        if (delayValue !== undefined && delayValue > 0) {
            setTimeout(pasteUsingApi, delayValue);
        } else {
            pasteUsingApi();
        }
    });

    function changeType(t) {
        resetView();
        let typeData = typeMap[t];
        if (typeData === undefined || typeData === null) {
            setDetails(`Error: Data for ${t} is null`);
            return;
        }
        fileSel.disabled = true;

        if (typeData.length !== undefined)
            setDetails(`size: ${typeData.length}, type: ${typeData.constructor.name}`);
        else if (typeData.size !== undefined)
            setDetails(`size: ${typeData.size}, type: ${typeData.constructor.name}`);

        if (t.startsWith('image/')) {
            setImage(typeData);
        } else if (t.startsWith('text/')) {
            setText(typeData, t);
        } else if (t === 'Files') {
            fileSel.disabled = false;
            fileSel.selectedIndex = 1;
            changeFile(Object.keys(fileMap)[0]);
        }
    }

    function changeFile(fileName) {
        resetView();
        let fileData = fileMap[fileName];
        if (fileData === undefined)
            return;
        setDetails(`type: ${fileData.type}, size: ${fileData.size}, modified: ${new Date(fileData.lastModified)}`);
        if (fileData.type.startsWith('image/')) {
            setImage(fileData);
        } else if (fileData.type.startsWith('text/')) {
            fileData.text().then((t) => setText(t));
        }
    }

    typeSel.addEventListener('change', function (e) {
        console.log(e);
        console.log(e.target.value);
        changeType(e.target.value);
    });
    fileSel.addEventListener('change', function (e) {
        console.log(e);
        console.log(e.target.value);
        changeFile(e.target.value);
    });

    document.querySelector('#copy-check').addEventListener('click', function (e) {
        if (e.target.checked) {
            copyButton.disabled = false;
            txt.hidden = false;
            txt.readOnly = undefined;
        } else {
            copyButton.disabled = true;
            txt.hidden = true;
            txt.readOnly = "readonly";
        }
    });

    copyButton.addEventListener('click', function (e) {
        console.log(`${e.timeStamp} ${e.type}`);
        let delayValue = document.querySelector('#clipboard-delay').value;
        // TODO: await? for safari
        setTimeout(async function () {
            console.assert(navigator.clipboard && typeof navigator.clipboard.read === 'function');
            if (!navigator.clipboard) {
                setDetails('Error: Cannot write using Clipboard API.');
                return;
            }
            try {
                // TODO: more types
                let mimeType = "text/plain";

                // TODO: make this a radio button choice
                // function later(delay, value) {
                //     return new Promise(function (resolve) {
                //         setTimeout(resolve, delay, value);
                //     });
                // }
                // let item = new ClipboardItem({ [mimeType]: later(2000, new Blob([txt.value], { type: mimeType })) });

                let item = new ClipboardItem({ [mimeType]: new Blob([txt.value], { type: mimeType }) });
                navigator.clipboard.write([item]);
            } catch (e) {
                setDetails(e);
                return;
            }
        }, (delayValue !== undefined && delayValue > 0) ? delayValue : 0);
    });

    document.addEventListener("copy", function (e) {
        console.log(`${e.timeStamp} ${e.type}`);
        // TODO: more types
        e.clipboardData.setData('text/html', txt.value);
        e.preventDefault();
    });

    document.addEventListener("paste", function (e) {
        console.log(`${e.timeStamp} ${e.type}`);
        resetAll();

        console.log(`types: ${e.clipboardData.types}`);

        for (let i = 0; i != e.clipboardData.types.length; ++i) {
            let type = e.clipboardData.types[i];
            typeMap[type] = e.clipboardData.getData(type);

            typeSel.disabled = false;
            let opt = document.createElement('option');
            opt.id = `type-sel-${i}`;
            opt.textContent = type;
            typeSel.append(opt);
        }

        console.log(`files: ${e.clipboardData.files.length}`);

        for (let i = 0; i != e.clipboardData.files.length; ++i) {

            let f = e.clipboardData.files[i];

            if (fileSel.disabled) {
                fileSel.disabled = false;
                let opt = document.createElement('option');
                fileSel.append(opt);
            }
            let opt = document.createElement('option');
            opt.textContent = f.name;
            fileSel.append(opt);

            console.log(`  name: ${f.name}; type: ${f.type}; size: ${f.size}; modified: ${new Date(f.lastModified)}`);
            fileMap[f.name] = new File([f], f.name, { type: f.type, lastModified: f.lastModified });
        }

        if (Object.keys(typeMap).length > 0) {
            typeSel.selectedIndex = 0;
            changeType(Object.keys(typeMap)[0]);
        }
    });
</script>

</html>